#!/bin/sh

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     (1) Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#
#    (2) Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#
#    (3)The name of the author may not be used to
#    endorse or promote products derived from this software without
#    specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# Next line ignored by tcl \
exec tclsh "$0" ${1+"$@"}

namespace eval flutio {
    variable usage \
"Usage: [info script] \[ -f system_config \] \[COMMAND\]

This command is used by flutio to start/connect a flutio processusing the
startup config file located in \$HOME/.flutio/startup.cfg

OPTIONS:
    -f       Path to the system.config file

When COMMAND is ommited, it is treated as it is start. It can be:
     start   Start the daemon and return
     kill    Kill the daemon
     status  Print the current player process status
     connect Connect to the flutio player and read/write commands/messages
             from/to stdin/stdout. This is the command used by the user
             interface. This command will start the flutio process if it
             is down.
     help    Print this messag
"
}

###########################################################################
# Catch missing libs
set s [info script]
while {[file type $s] == "link"} { set s [file link $s] }
set ::flutio::libdir [file dirname $s]
lappend auto_path [file join $::flutio::libdir pkgs]
if [catch {
        package require Tcl         8.6
        package require unixsocket  1.0
        package require taglib      1.0
        package require tclreadline 2.3
        load [file join $::flutio::libdir libtclflutio.so] } msg] {
    puts stderr "flutio won't start: $msg"
    exit 1
}

###########################################################################
# Check if command is valid
if {$argc == 0} {
    set ::flutio::system_config \
                               [file join $env(HOME) .flutio system.config]
    set ::flutio::command start
} elseif {$argc == 1} {
    set ::flutio::system_config \
                               [file join $env(HOME) .flutio system.config]
    set ::flutio::command [lindex $argv 0]
} elseif {$argc == 2 && [lindex $argv 0] == "-f"} {
    set ::flutio::system_config [lindex $argv 1]
    set ::flutio::command start
} elseif {$argc == 3 && [lindex $argv 0] == "-f"} {
    set ::flutio::system_config [lindex $argv 1]
    set ::flutio::command [lindex $argv 2]
} else {
    puts stderr "Failed to execute $argv"
    puts stderr $::flutio::usage
    exit 1
}

if {[lsearch {start kill status connect help daemon} \
                                            $::flutio::command] == -1} {
    puts stderr "Failed to execute $argv"
    puts stderr $::flutio::usage
    exit 1
}

###########################################################################
# Ok then, script variables for the default per user process. May be
# overwriten by the startup.config
# TODO ici lire le ficher startup, mais seulement ce qui est du contexte
# sysconfig, sinon les valeurs par defaut
set ::flutio::home_dir    [file join $env(HOME) .flutio]
set ::flutio::startup_cfg [file join $::flutio::home_dir startup.config]
set ::flutio::pid_file    [file join $::flutio::home_dir running.pid]
set ::flutio::msg_log     [file join $::flutio::home_dir messages.log]
set ::flutio::err_log     [file join $::flutio::home_dir errors.log]
set ::flutio::socket_path [file join $::flutio::home_dir flutio.socket]

###########################################################################
# Create home directory if absent
if {! [file exist $::flutio::home_dir]} {
    file mkdir $::flutio::home_dir
    file attribute $::flutio::home_dir -permissions 0700
}

###########################################################################
# Here define all commands functions but the stelth "daemon" one.
#
namespace eval ::flutio {

    #######################################################################
    # flutio start
    proc start {} {
        return 0
    }

    #######################################################################
    # flutio status
    proc status {} {
        if [file exist $::flutio::pid_file] {
            set f [open $::flutio::pid_file "r"]
            set fpid [read $f]
            close $f
            puts "flutio $fpid running"
        } else {
            puts "flutio down"
        }
        return 0
    }

    ####################################################################
    ##
    # flutio help
    proc help {ret} {
        if { $ret == 0 } {
            puts stdout $::flutio::usage
        } else {
            puts stderr $::flutio::usage
        }
        return $ret
    }

    #######################################################################
    # flutio connect
    proc connect {} {
        if { ! [file exist $::flutio::pid_file] } {
            set ret [exec [info script] start]
            if {$ret > 0} {
                puts "flutio connect: error starting flutio"
                return $ret
            }
        }

        if { ! [file exist $::flutio::socket_path] } {
            puts "flutio connect: $::flutio::socket_path does not exists"
            return 1
        }

        return 0
    }

    #######################################################################
    # flutio kill
    proc kill {} {
        if [file exist $::flutio::pid_file] {
            set f [open $::flutio::pid_file "r"]
            set fpid [read $f]
            close $f
            set ret [exec kill $fpid]
            if {$ret == 0} {
                puts "flutio process $fpid killed"
            }
            file delete $::flutio::pid_file
            return $ret
        } else {
            puts "No flutio process running"
            return 0
        }
    }
}

###########################################################################
# Handle script command argument
switch [lindex $argv 0] {
    "daemon"  {}
    "start"   {exit [::flutio::start]}
    "kill"    {exit [::flutio::kill]}
    "status"  {exit [::flutio::status]}
    "connect" {exit [::flutio::connect]}
    "help"    {exit [::flutio::help 0]}
    default   {exit [::flutio::help 1]}
}

###########################################################################
# !!!         ONLY THE "flutio daemon" COMMAND GOES OVER THERE         !!!!
###########################################################################

proc ::flutio::main {} {

    if {[file exists $::flutio::startup_config] != 1} {
        ::flutio::command "switch-context system"
        ::flutio::command "write running.config startup.config"
    }
    set fd [open "/home/seb/src/flutio/startup.config" "r"]
    foreach line [split [read $fd] "\n"] {
        ::flutio::command $line
    }
    close $fd


    #######################################################################
    # Load all possible plugins
    foreach plugdir $::flutio::plugdirs {
        set pluglibs [glob -nocomplain -directory $plugdir "*.so"]
        foreach plugin $pluglibs {
            puts "will load $plugin"
            ::flutio::c::plugins::load $plugin
        }
    }

    ::flutio::c::outputs::open



    set test_set [glob -nocomplain -directory /home/seb/test/ "*.wav"]
    set ::flutio::playlist::tracks [lsort -dictionary $test_set]
    puts stderr $test_set

    ::flutio::playlist::play 0
    vwait _cataclysm_
}

namespace eval ::flutio::contexts {
    variable root    {}
    variable current_context {}
    variable context_error 1

    proc unregister {name} {
        variable root
        dict remove root {*}$name
    }

    proc register {name fun} {
        variable root
        dict set root {*}$name handler $fun
    }

    proc evaluate {cmd} {
        variable current_context
        variable context_error
        variable root
        if {[lindex $cmd 0] == "switch-context"} {

            if {[llength $cmd] < 2} {
                return "/[string join $current_context "/"]"
            }

            set cname_orig [lindex $cmd 1]
            if {[string match "/*" $cname_orig]} {
                # absolute
                set cname [split $cname_orig "/"]

            } else {
                # relative
                set cname [concat $current_context [split $cname_orig "/"]]
            }

            puts "$root"
            puts "$current_context"
            if {[catch {dict get $root {*}$current_context handler} handler]} {
                set context_error 1
                return "wront context name /[join $current_context "/"]"
            }

            return $cname
        } else {
            set handler [dict get $root {*}$current_context handler]
            ${handler} $current_context $cmd
        }
    }
}

namespace eval ::flutio::configure {

    proc eval {cmd} {
        puts "configure!!!! $cmd"
    }

    ::flutio::contexts::register [list configure] ::flutio::configure

}


proc ::flutio::command {str} {
    set str [string tolower [string trim $str]]
    if {[string match "#*" $str] || [string length $str] == 0} {
        return
    }
    set cmd [split $str]
    ::flutio::contexts::evaluate $cmd

}


namespace eval ::flutio::usocket {
    variable connexions

    proc accept {con} {
        puts "hello $con"
    }

}

namespace eval ::flutio::playlist {
    variable tracks [list]
    variable current_track -1
    variable next_track    -1

    proc play {index} {
        variable tracks
        variable current_track
        variable next_track

        set numTracks [llength $tracks]

        if {[llength $tracks] == 0} {
            puts stderr "no tracks to play"
            return
        }

        if {$index > $numTracks} {
            puts stderr "no tracks at index $index"
            return
        }

        if {$index < 0} {
            set index 0
        }

        if {[catch {::flutio::c::player::play \
                            [lindex $tracks $index]} err] == 0 } {
            set current_track $index
            #::flutio::playlist::setnext
        } else {
            puts stderr "Can not play [lindex $tracks $index]"
        }
    }

    proc setnext {} {
        variable tracks
        variable current_track
        variable next_track

        set maybe_next [expr $current_track + 1]
        if {$maybe_next > [llength $tracks]} {
            return
        }

        if {[catch {::flutio::c::player::setnext \
                        [lindex $tracks $maybe_next]} err] == 0} {
            set next_track $maybe_next
        } else {
            puts stderr "Can not setnext [lindex $tracks $maybe_next]"
            set next_track -1
        }
    }
}

namespace eval ::flutio::collection {
}

::flutio::main
